2020 年底公司和阿里健康合作了一个检验项目，由我司提供检验项目(商品)、采样点(商户)、库存等底层数据，与阿里健康开发对接后在支付宝平台进行在线预售，开发流程其中也包括订单数据的交互。

项目开发期间踩了比较多的坑，做了很多优化，其中也包含一些有意思的技术实现方案。

### 一、时间轮实践

某些业务场景下，我们需要频繁调用阿里健康接口，项目第一个版本上线后，发现有部分请求触发阿里健康接口流控告警，原因是他们提供的接口在一定的时间内只允许 N 次接口调用。针对这个问题，想到了以下几种实现方式：

 1. sleep 同步调用：对批量数据进行拆分，每条数据都 sleep 一段时间
 2. ScheduledExecutorService 异步调用：延迟任务，通过线程池调度
 3. HashedWheelTimer(Netty) 异步调用：将批量数据按照一定延迟时间添加到时间轮队列中，等待调度

第 1 种方案如果同步批量数据过多，sleep 后客户端一直得不到响应，直接 pass。第 2 种方案需要频繁的创建和销毁线程池，考虑到客户端交互频繁，选择了时间轮方案。

当有任务添加到队列中后，Netty 时间轮会开启一个工作线程，后续所有任务的执行都依赖这个线程，因此不会频繁创建与销毁线程资源。但是有一个缺陷是当没有任务时，这个线程会一直空转，只要不同时存在多个时间轮，这个空转是可以接受的。

Netty 时间轮原理如下：

![](https://raw.githubusercontent.com/zhchenme/go/master/image/%E5%9F%BA%E7%A1%80/wheel-timer.png)

关于 Netty 时间轮设计原理，可以看下我这篇文章的总结：[Netty 时间轮原理分析](https://github.com/zhchenme/go/blob/master/%E5%9F%BA%E7%A1%80/20-12-24-netty%E6%97%B6%E9%97%B4%E8%BD%AE%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.md)

### 二、检验项目库存实现方案

#### 2.1 库存预生成方案

刚开始的库存设计方案比较简单，运营人员先在后台绑定采样点与检验项目的关系，然后设置排期和具体日期对应的库存，后端接收到数据后直接入库。对应的关系模型如下：

![](https://raw.githubusercontent.com/zchen96/java-memo/master/image/%E4%B8%9A%E5%8A%A1/11.examination_stock_pre_init.png)

由于是在线预售业务，一般会对未来一个月内的日期进行排期。如果有 X 家采样点，一家采样点绑定了 N 个项目，排期天数设置为 M 天，就需要在数据库中保存 X * N * M 条记录。随着时间推移 M 越来越大，数据量也就越来越多。

这种设计方案比较容易理解，和订单交互的流程也比较简单，但是有一个很严重的问题是会预生成大量的库存数据，业务发展不到两个月就已经生成了 200w+ 的数据量。

对这些数据进行分析后发现 95% 的数据都是无用的，于是想了以下两种方案解决这个问题：

 1. 预先生成逻辑不变，通过定时任务扫描库存表，删除无效数据，无效数据主要指非未来时间且没有库存变更的数据
 2. 延迟生成库存，当未发生库存变更请求时不生成库存，针对查询操作，通过业务代码构造库存信息，当库存变更时延迟生成库存

第一种方案实现比较简单，原先的业务逻辑不变，只需要定义一个库存清除任务即可。当删除 MySQL 表数据时，这些数据所占用的空间可能会被标记为可复用，并不会释放磁盘空间，出于这个考虑选择了第二个方案。

#### 2.2 延迟库存生成方案

延迟库存生成逻辑如下：

![](https://raw.githubusercontent.com/zchen96/java-memo/master/image/%E4%B8%9A%E5%8A%A1/10.examination_stock_delay_init_process.png)

库存细节：分布式锁，数据库

### 总结

全面考虑问题，一开始就要考虑到阿里健康接口调用规范。