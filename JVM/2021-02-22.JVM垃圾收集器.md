### CMS

CMS(Concurrent Mark Sweep)重视服务的响应速度，着力于减少系统的停顿时间，以带来更好的用户体验。CMS 由标记-清除算法实现，用来回收老年代的内存垃圾，可以搭配 ParNew 混合使用。

清理过程：

 1. 初始标记：Stop The World，标记 GC Root 直接关联的对象，速度很快
 2. 并发标记：GC Root Tracing 过程
 3. 重新标记：Stop The World，为了修正并发标记期间，因用户程序继续执行而导致变动的对象记录
 4. 并发清除：垃圾回收

整个过程中最耗时的并发标记与并发清除阶段都可以用用户线程一起工作，因此并发执行，低停顿是其主要特点。

缺陷：

 1. 与用户线程并发执行因此对 CPU 资源敏感
 2. 并发清除阶段与用户线程并发执行，无法处理并发清除阶段产生的浮动垃圾
 3. 采用标记-清理算法，会产生内存碎片，对于大对象的内存分配不友好

### G1

G1 算法将堆划分为若干个区域（Region），它仍然属于分代收集器。新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者 Survivor 空间。

G1 收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。这就意味着，在正常的处理过程中，G1 完成了堆的压缩（至少是部分堆的压缩），这样也就不会有 CMS 内存碎片问题的存在了。

![](https://raw.githubusercontent.com/zhchenme/go/master/image/%E5%9F%BA%E7%A1%80/g11.png)

如果一个对象占用的空间超过了分区容量 50% 以上，G1 收集器就认为这是一个巨型对象。这些巨型对象，默认直接会被分配在年老代。如果一个 Humongous 区域装不下一个巨型对象，那么 G1 会寻找连续的 Humongous 区域来存储。为了能找到连续的 Humongous 区域，有时候不得不启动 Full GC。

G1 相比 CMS 的优点：

 - 有整理内存过程的垃圾收集器，不会产生很多内存碎片
 - G1 的 Stop The World 更可控，G1 在停顿时间上添加了预测机制，用户可以指定期望停顿时间

GC 的最基本的参数：

```java
-XX:+UseG1GC -Xmx32g -XX:MaxGCPauseMillis=200
```

#### Young GC

Young GC 主要是对 Eden 区进行 GC，它在 Eden 空间耗尽时会被触发。

在这种情况下，Eden 空间的数据移动到 Survivor 空间中，如果 Survivor 空间不够，Eden 空间的部分数据会直接晋升到老年代空间。Survivor 区的数据移动到新的 Survivor 区中，也有部分数据晋升到老年代空间中。

如果仅仅 GC 新生代对象，我们如何找到所有的根对象呢？老年代的所有对象都是根么？那这样扫描下来会耗费大量的时间。于是，G1 引进了 RSet 的概念。它的全称是 Remembered Set，作用是跟踪指向某个 heap 区内的对象引用。

G1 中使用 point-in 来解决。point-in 的意思是哪些分区引用了当前分区中的对象。这样，仅仅将这些对象当做根来扫描就避免了无效的扫描。

由于新生代有多个，那么我们需要在新生代之间记录引用吗？这是不必要的，原因在于每次 GC 时，所有新生代都会被扫描，所以只需要记录老年代到新生代之间的引用即可。

如果引用的对象很多，赋值器需要对每个引用做处理，赋值器开销会很大，为了解决赋值器开销这个问题，在 G1 中又引入了另外一个概念，卡表（Card Table），Card Table 是一种 points-out（我引用了谁的对象）的结构。

一个 Card Table 将一个分区在逻辑上划分为固定大小的连续区域，每个区域称之为卡。卡通常较小，介于 128 到 512 字节之间。Card Table 通常为字节数组，由 Card 的索引（即数组下标）来标识每个分区的空间地址。

默认情况下，每个卡都未被引用。当一个地址空间被引用时，这个地址空间对应的数组索引的值被标记为“0”，即标记为脏或被引用，此外 RSet 也将这个数组下标记录下来。

一般情况下，这个 RSet 其实是一个 Hash Table，Key 是别的 Region 的起始地址，Value 是一个集合，里面的元素是 Card Table 的 Index。

![](https://raw.githubusercontent.com/zhchenme/go/master/image/%E5%9F%BA%E7%A1%80/G1-card-table.jpg)

上图中有三个 Region，每个 Region 被分成了多个 Card，在不同 Region 中的 Card 会相互引用，Region1 中的 Card 中的对象引用了 Region2 中的 Card 中的对象，蓝色实线表示的就是 points-out 的关系，而在 Region2 的 RSet 中，记录了 Region1 的 Card，即红色虚线表示的关系，这就是 points-into。

#### Mix GC

Mix GC 不仅进行正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的老年代分区。

#### 触发 Full GC

在某些情况下，G1 触发了 Full GC，这时 G1 会退化使用 Serial 收集器来完成垃圾的清理工作，它仅仅使用单线程来完成 GC 工作，GC 暂停时间将达到秒级别的。

 - 并发模式失败
 - 巨型对象分配失败
 - 晋升失败或者疏散失败

### 参考

《深入理解 Java 虚拟机》 <br>
[深入理解 Java G1 垃圾收集器](http://ghoulich.xninja.org/2018/01/27/understanding-g1-garbage-collector-in-java/) <br>
[Java Hotspot G1 GC的一些关键技术](https://tech.meituan.com/2016/09/23/g1.html) <br>