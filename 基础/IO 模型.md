### 一、IO 底层

linux 将内存分为内核区，用户区，linux 内核给我们管理所有的硬件资源，应用程序通过调用系统调用和内核交互，达到使用硬件资源的目的； 应用程序通过系统调用 read 发起一个读操作；这时候内核创建一个文件描述符，并通过驱动程序向硬件发送读指令，并将读的的数据放在这个描述符对应结构体的缓存区。但这个结构体是在内核内存区的。需要将这个数据读到用户区。这样完成了一次读操作。

**1.1 用户空间与内核空间**

操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对 linux 操作系统而言，将最高的 1G 字节（从虚拟地址 0xC0000000 到 0xFFFFFFFF），供内核使用，称为内核空间，而将较低的 3G 字节（从虚拟地址 0x00000000 到 0xBFFFFFFF），供各个进程使用，称为用户空间。

**1.2 进程切换**

为了控制进程的执行，内核必须有能力挂起正在 CPU 上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换，这个过程是很消耗 CPU 资源的。

从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：

 1.保存处理机上下文，包括程序计数器和其他寄存器
 2.更新 PCB 信息
 3.把进程的 PCB 移入相应的队列，如就绪、在某事件阻塞等队列
 4.选择另一个进程执行，并更新其 PCB
 5.更新内存管理的数据结构
 6.恢复处理机上下文

**1.3 文件描述符 fd**

文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。

文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。

**1.4 缓存 IO**

缓存 IO 又被称作标准 IO，大多数文件系统的默认 IO 操作都是缓存 IO。在 Linux 的缓存 IO 机制中，操作系统会将 IO 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。


数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。

### 二、阻塞非阻塞 & 同步异步

**2.1 阻塞非阻塞**

- 阻塞：当某个事件或者任务在执行过程中，它发出一个请求操作，但是由于该请求操作需要的条件不满足，那么就会一直在那等待，直至条件满足
- 非阻塞：当某个事件或者任务在执行过程中，它发出一个请求操作，如果该请求操作需要的条件不满足，会立即返回一个标志信息告知条件不满足，不会一直在那等待

两者区别：当发出请求一个操作时，如果条件不满足，是会一直等待还是返回一个标志信息。

**2.2 同步异步**

- 同步：如果有多个任务或者事件要发生，这些任务或者事件必须逐个地进行，一个事件或者任务的执行会导致整个流程的暂时等待，这些事件没有办法并发地执行
- 如果有多个任务或者事件发生，这些事件可以并发地执行，一个事件或者任务的执行不会导致整个流程的暂时等待

举个栗子：假如有一个任务包括两个子任务 A 和 B，对于同步来说，当 A 在执行的过程中，B 只有等待，直至 A 执行完毕，B 才能执行；而对于异步就是 A 和 B 可以并发地执行，B 不必等待 A 执行完毕之后再执行，这样就不会由于 A 的执行导致整个任务的暂时等待。

两者区别：在于多个任务和事件发生时，一个事件的发生或执行是否会导致整个流程的暂时等待。


### 三、IO 类型

**3.1 阻塞非阻塞 IO**

当用户线程发起一个 IO 请求操作（以读请求为例），内核会去查看要读取的数据是否就绪，对于阻塞 IO 来说，如果数据没有就绪，则会一直在那等待，直到数据就绪；对于非阻塞 IO 来说，如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读的数据没有就绪。当数据就绪之后，便将数据拷贝到用户线程，这样才完成了一个完整的 IO 读请求操作，也就是说一个完整的 IO 读请求操作包括两个阶段：

- 查看数据是否就绪
- 进行数据拷贝（内核将数据拷贝到用户线程）

阻塞（blocking IO）和非阻塞（non-blocking IO）的区别就在于第一个阶段，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。

**3.2 同步异步 IO**

- 同步 IO：当用户发出 IO 请求操作之后，如果数据没有就绪，需要通过用户线程或者内核不断地去轮询数据是否就绪，当数据就绪时，再将数据从内核拷贝到用户线程
- 异步 IO：只要 IO 请求操作的发出是由用户线程来进行的，IO 操作的两个阶段都是由内核自动完成，然后发送通知告知用户线程 IO 操作已经完成。也就是说在异步 IO 中，不会对用户线程产生任何阻塞。

同步 IO 和异步 IO 的关键区别反映在数据拷贝阶段是由用户线程完成还是内核完成。所以说异步 IO 必须要有操作系统的底层支持。



### 四、IO 多路复用

**4.1 select**






### 参考

(Java NIO：浅析I/O模型)[http://www.cnblogs.com/dolphin0520/p/3916526.html] by 海子<br>
(深入浅出异步I/O模型)[https://alicsd.iteye.com/blog/868702] by 老徐 <br>
(聊聊Linux 五种IO模型)[https://www.jianshu.com/p/486b0965c296] by 猿码道 <br>