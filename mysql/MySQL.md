[MySQL 是怎样运行的：从根儿上理解 MySQL](https://juejin.cn/book/6844733769996304392) 小册笔记。

### 基础

#### 杂

MySQL 中 utf8 与 utf8mb4 的区别：
 - utf8（utf8mb3）：使用 1～3 个字节表示字符
 - utf8mb4（utf8 most bytes 4）：使用 1～4 个字节表示字符

在 MySQL 中 utf8 是 utf8mb3 的别名，因此在 MySQL 中 utf8 最多只能存储 3 个字节，PS：emoji 表情占 4 个字节。

页是 MySQL 中磁盘和内存交互的基本单位，也是 MySQL 是管理存储空间的基本单位，一个页的大小一般是 16KB。

页通过头信息 `next_record` 属性将页中的数据构成一个单向链表，链表中的各个节点按照主键由小到大的顺序连接。每个数据页都有上一个和下一个页的编号，所以所有页通过双向链表连接。

InnoDB 会把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个槽，存放在 Page Directory 中，在一个页中根据主键查找记录流程如下：
 
 1. 通过二分法确定数据所在的槽
 2. 遍历该槽中的链表

#### 系统数据库

 - mysql：账户、权限、存储过程、事件定义、运行过程中产生的日志等
 - information_schema：对 MySQL 服务器进行维护的信息
 - performance_schema：MySQL 服务器运行状态信息，性能监控
 - sys：通过视图的方式结合 information_schema 与 performance_schema 信息

#### 外连接原理

 - 驱动表：第一个需要查询的表
 - 被驱动表：非驱动表

内连接驱动表与被驱动表角色可以互换。假设现在两表连接 t1(驱动表)，t2(被驱动表)。

 1. 选取驱动表，使用与驱动表相关的过滤条件，选取代价最低的单表访问方法来执行对驱动表的单表查询
 2. 用驱动表获得的数据都分别到被驱动表中查找匹配的记录

因此，多个被驱动表也可以理解为多层循环。

MySQL 用 join buffer 存储驱动表结果集数据，将数据保存在内存中。并不是所有列都会被放到 join buffer 中，只有查询列表中的列和过滤条件中的列才会被放到 join buffer 中，所以最好不要把 `*`作为查询列表。


### 索引

#### InnoDB

![](https://raw.githubusercontent.com/zhchenme/go/master/image/%E5%9F%BA%E7%A1%80/index-innodb.png)

MySQL 索引结构：

 - 目录项记录：`record_type` 值是1，而普通用户记录的 `record_type` 值是 0
 - 用户记录：目录项记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有 InnoDB 自己添加的隐藏列
 - ....

B+ 树的内节点(非叶子结点)目录项记录中存储的是索引列 + 最小主键值 + 页号，B+ 树本身就是一个索引，索引即数据，数据即索引。

聚簇索引：

 1. 使用记录主键值的大小进行记录和页的排序
    - 页内的记录是按照主键的大小顺序排成一个单向链表
    - 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表
    - 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表
 2. B+ 树的叶子节点存储的是完整的用户记录

二级索引：

聚簇索引只能在搜索条件是主键值时才能发挥作用，因为 B+ 树中的数据都是按照主键进行排序的。

非主键索引，先根据索引字段找到具体的记录，根据记录的主键去聚簇索引中再查找一遍完整的用户记录，这个过程也叫回表。

聚簇索引与二级索引有什么区别？

聚簇索引的叶子结点包含了完整的表记录，而二级索引只包含主键字段与主键。

B+ 树索引构建过程：

 1. 为 B+ 树索引创建一个根目录，表中没有数据的时候，根结点中既没有用户记录也没有目录项记录
 2. 向表中插入数据，用户记录会先存储到根结点中
 3. 根结点空间用完，将根结点中所有的记录复制到新的页中，比如页 A，然后对这个页进行页分裂操作，得到另一个新的页，比如页 B。这时新插入的记录就会被分配到 A 或者 B 中，而根结点自动升级为存储目录项记录的页

什么是随机 I/O？

索引中所有数据都是连续的，如果对二级索引进行一些查询(比如 IN 等)，由于二级索引不记录所有的数据，需要根据主键回表查询，如果这些需要回表的主键不连续，在主键索引回表查询时就是随机 I/O。

#### MyISAM

![](https://raw.githubusercontent.com/zhchenme/go/master/image/%E5%9F%BA%E7%A1%80/index-myisam.png)

MyISAM 将表中的数据按照插入顺序单独存储在一个文件中被称为“数据文件”，这个文件并不由页构成，有多少数据就塞多少数据，可以通过行号快速访问到一条记录。

MyISAM 将索引信息存储到一个索引文件中，这个文件仍然是 B+ 树结构，只不过叶子结点不存储完整的数据记录，而是主键值 + 行号。因为不存储完整的数据记录，因此 MyISAM 索引全部都是二级索引，查找完整的数据需要回表。

#### 索引使用建议

索引适用情况：

 - 全值匹配
 - 匹配左边的列
 - 匹配范围值
 - 精确匹配某一列并范围匹配另外一列
 - 用于排序
 - 用于分组

索引注意事项：

 - 只为用于搜索、排序或分组的列创建索引
 - 为列的基数大的列创建索引
 - 索引列的类型尽量小
 - 可以只对字符串值的前缀建立索引
 - 只有索引列在比较表达式中单独出现才可以适用索引
 - 为了尽可能少的让聚簇索引发生页面分裂和记录移位的情况，建议让主键拥有 `AUTO_INCREMENT` 属性
 - 定位并删除表中的重复和冗余索引
 - 尽量使用覆盖索引进行查询，避免回表带来的性能损耗

#### 数据访问方法

 - const：通过主键或者唯一二级索引列与常数的等值比较来定位一条记录是像坐火箭一样快的，所以把这种通过主键或者唯一二级索引列来定位一条记录的访问方法定义为：`const`。如果主键或者唯一二级索引是由多个列构成的话，索引中的每一个列都需要与常数进行等值比较，这个 `const` 访问方法才有效（这是因为只有该索引中全部列都采用等值比较才可以定位唯一的一条记录）
 - ref：搜索条件为二级索引列与常数等值比较，采用二级索引来执行查询的访问方法称为：`ref`
    - 不论是普通的二级索引，还是唯一二级索引，它们的索引列对包含 `NULL` 值的数量并不限制，所以我们采用 `key IS NULL` 这种形式的搜索条件最多只能使用 `ref` 的访问方法，而不是 `const` 的访问方法
 - range：利用索引进行范围匹配的访问方法称之为：`range`
 - index：采用遍历二级索引记录的执行方式称之为：`index`
 - all：全表扫描执行查询的方式称之为：`all`

#### 索引合并

一般情况下只能利用单个二级索引执行查询，其中 key1 与 key2 都是单独字段的二级索引 SQL 如下：

```sql
SELECT * FROM single_table WHERE key1 = 'abc' AND key2 > 1000;
```

查询过程：

 1. 根据条件 `key1 = 'abc'` 从 idx_key1 索引代表的 B+ 树中找到对应的二级索引记录
 2. 回表阶段再根据条件 `key2 > 1000` 得到完整的用户记录继续过滤。将最终符合过滤条件的记录返回给用户

MySQL 在一般情况下执行一个查询时最多只会用到单个二级索引，特殊情况下也可能在一个查询中使用到多个二级索引，使用到多个索引来完成一次查询的执行方法称之为：index merge。

例如下面这个例子：

```sql
SELECT * FROM single_table WHERE key1 = 'a' AND key2 = 'b';
```

查询过程：

 1. 从 idx_key1 二级索引对应的 B+ 树中取出 `key1 = 'a'` 的相关记录
 2. 从 idx_key3 二级索引对应的 B+ 树中取出 `key3 = 'b'` 的相关记录
 3. 根据两个索引计算出 id 交集
 4. 根据 id 交集数据回表，将查到的记录返回给用户

为什么将索引数据合并？

虽然读取多个二级索引比读取一个二级索引消耗性能，但是读取二级索引的操作是顺序 I/O，而回表操作是随机 I/O，所以如果只读取一个二级索引时需要回表的记录数特别多，而读取多个二级索引之后取交集的记录数非常少，读取多个二级索引后取交集比只读取一个二级索引的成本更低。

MySQL 只在特定的情况下才会将索引合并：

 - 二级索引列是等值匹配的情况
 - 主键列可以是范围匹配

......

