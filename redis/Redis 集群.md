### 一、集群简介

集群由多个节点 (Node) 组成，Redis 的数据分布在这些节点中。集群中的节点分为主节点和从节点：只有主节点负责读写请求和集群信息的维护，从节点只进行主节点数据和状态信息的复制

集群节点和单机服务器一个重要区别是，集群节点只能处理 0 号数据库，而单机服务器能处理 0 - 15 号中的任何一个数据库。

集群的作用，可以归纳为两点：

 1. 数据分区：数据分区 (或称数据分片) 是集群最核心的功能
     - 集群将数据分散到多个节点，一方面突破了 Redis 单机内存大小的限制，存储容量大大增加；另一方面每个主节点都可以对外提供读服务和写服务，大大提高了集群的响应能力
     - Redis 单机内存大小受限问题，在介绍持久化和主从复制时都有提及；例如，如果单机内存太大，bgsave 和 bgrewriteaof 的 fork 操作可能导致主进程阻塞，主从环境下主机切换时可能导致从节点长时间无法提供服务，全量复制阶段主节点的复制缓冲区可能溢出
 2. 高可用：集群支持主从复制和主节点的自动故障转移（与哨兵类似）；当任一节点发生故障时，集群仍然可以对外提供服务

### 二、集群原理

#### 2.1 节点握手

Redis 集群连接各个节点通过命令 `CLUSTER MEET <ip> <port>` 命令实现，实现原理如下
 
 1. 节点 A 为节点 B 创建一个 `clusterNode` 结构，并将该结构添加到自己的 `clusterState.nodes` 字典里
 2. 节点 A 根据命令给定的 IP 与 port，向节点 B 发送一条 `MEET` 消息
 3. 节点 B 接收到节点 A 的 `MEET` 消息，为 A 创建一个 `clusterNode` 结构，并将该结构添加到自己的 `clusterState.nodes` 字典里
 4. 节点 B 向节点 A 返回一个 `PONG` 消息
 5. 节点 A 接收到节点 B 的 `PONG` 消息，确认节点 B 已经接收到了自己发送的 `MEET` 消息，接着节点 A 向节点 B 返回一条 `PING` 消息
 6. 节点 B 接收到节点 A 的 `PING` 消息，握手完成
 7. 节点 A 将节点 B 的信息通过 Gossip 协议传播给集群中的其他节点，让其他节点与 B 握手

#### 2.2 槽分片

Redis 通过分片的形式存储键值对：集群分为 16384 个槽，集群中的每一个键都属于这些槽中的一个。当 13684 个槽都有节点处理时，集群才处于 OK 状态，如果有一个槽没有被份额皮，那么集群就处于下线状态。

槽分配使用 `CLUSTER ADDSLOTS <slot> [slot ...]` 命令实现。集群中的每个节点除了会记录槽信息外还会将这些信息通过消息发送给集群中的其他节点，这样一来集群中的每个节点都会知道 13684 个槽都给分配给了哪个节点。

#### 2.3 MOVED 错误

在集群中操作键时，如果这个键所在的槽不属于当前节点时，节点会向客户端返回一个 `MOVED` 错误，指引客户端转向真实负责槽的节点。`MOVED` 错误格式：`MOVED <slot> <ip> <port>`

#### 2.4 重新分片

Redis 集群节点可以将自己负责的槽指派给任何一个集群中的其他节点，并且槽关联下的所有数据也会从源节点转移到目前节点。重新分片的过程可以在线进行，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求。

#### 2.5 ASK 错误

集群重新分片期间，源节点向目前节点迁移一个槽的过程中，可能会出现一种情况：一部分键值对保存在源节点，一部分数据保存在目标节点，这时一个请求进来，恰好属于正在迁移中的源节点，源节点会尝试在自己的数据库中查找 key，如果找到直接返回客户端发送的命令。

如果没有在源节点找到 key，会先检查 key 所属的槽是否正在迁移，如果正在迁移，节点会向客户端返回一个 `ASK` 错误，引导客户端到目标节点中查找。

接到 `ASK` 错误的客户端会根据提示的 IP 与端口，转向目标节点，首先会向目标节点发送一个 `ASKING` 命令，之后再发送要执行的命令。`ASKING` 命令的目的是用于打开发送该命令客户端的	 `REDIS_ASKING` 标识，如果客户端不发送 `ASKING` 命令，客户端发送的命令会被源节点拒绝，并返回 `MOVED` 错误。

客户端的 `REDIS_ASKING` 是一个一次性标识，当第一次执行后会被移除，todo 待验证。


### 三、故障恢复

#### 3.1 故障检测

集群中的每个节点都会定期的向其他节点发送 `PING` 命令，用来检测对方是否下线，如果接收到 `PING` 消息的服务器没有在规定的时间内返回 `PONG` 消息，那么发送 `PING` 消息的节点会将目标节点标记为疑似下线状态（PFAIL）

集群中的各个节点会互相发送消息来交换集群中各个节点的状态信息，比如 A 节点通过消息得知 B 将 C 节点标记为疑似下线状态，A 接收到该消息后，会将该报告保存在自己的数据结构里

如果半数以上负责处理槽的节点认为 X 节点疑似下线，会把 X 节点会被标记为下线状态（FAIL），而标记 X 节点下线的节点会向集群中广播一条节点 X 节点下线的消息，让其他节点知晓

#### 3.2 选举新节点

新节点的选举与 Sentinel 选举类似：

 1. 当从节点发现自己复制的主节点进入已下线状态，从节点会向集群广播一条消息，要求所有收到该消息的有投票权（拥有槽）的主节点给自己头片
 2. 在一个配置纪元内（初始为 0），集群里每个负责处理槽节点的主节点都有一次投票机会，第一个向主节点要求投票的从节点将会获得主节点的投票
 3. 具有投票权切尚未投票的主节点接收到从节点发来的消息后，会返回一条消息，表示支持从节点成为新的主节点
 4. 当一个从节点获得 N/2 + 1 个票时，会成为新的主节点
 5. 在一个配置纪元内，如果出现平票的情况，集群会进入一个新的纪元（+1），再次进行选择，直至选出新的主节点

#### 3.3 故障迁移

 1. 被选中的从节点会执行 `SLAVEOF no one` 命令，成为新的主节点
 2. 迁移下线的主节点的槽，全部指派给自己
 3. 新的主节点向集群中广播一条 `PONG` 消息，这个 `PONG` 消息会让集群中的其他节点立即知道这个节点转正了
 4. 新的主节点开始处理和自己相关的槽的命令，故障转移完成

#### 四、集群中的消息


### 参考

《Redis 设计与实现》 <br>
[深入学习 Redis（5）：集群 ](https://www.cnblogs.com/kismetv/p/9853040.html) <br>