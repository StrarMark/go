### 一、集群简介

集群由多个节点 (Node) 组成，Redis 的数据分布在这些节点中。集群中的节点分为主节点和从节点：只有主节点负责读写请求和集群信息的维护；从节点只进行主节点数据和状态信息的复制

集群的作用，可以归纳为两点：

 1. 数据分区：数据分区 (或称数据分片) 是集群最核心的功能
     - 集群将数据分散到多个节点，一方面突破了 Redis 单机内存大小的限制，存储容量大大增加；另一方面每个主节点都可以对外提供读服务和写服务，大大提高了集群的响应能力
     - Redis 单机内存大小受限问题，在介绍持久化和主从复制时都有提及；例如，如果单机内存太大，bgsave 和 bgrewriteaof 的 fork 操作可能导致主进程阻塞，主从环境下主机切换时可能导致从节点长时间无法提供服务，全量复制阶段主节点的复制缓冲区可能溢出
 2. 高可用：集群支持主从复制和主节点的自动故障转移（与哨兵类似）；当任一节点发生故障时，集群仍然可以对外提供服务

### 二、

#### 2.1 节点握手

Redis 集群连接各个节点通过命令 `CLUSTER MEET <ip> <port>` 命令实现，实现原理如下
 
 1. 节点 A 为节点 B 创建一个 `clusterNode` 结构，并将该结构添加到自己的 `clusterState.nodes` 字典里
 2. 节点 A 根据命令给定的 IP 与 port，向节点 B 发送一条 `MEET` 消息
 3. 节点 B 接收到节点 A 的 `MEET` 消息，为 A 创建一个 `clusterNode` 结构，并将该结构添加到自己的 `clusterState.nodes` 字典里
 4. 节点 B 向节点 A 返回一个 `PONG` 消息
 5. 节点 A 接收到节点 B 的 `PONG` 消息，确认节点 B 已经接收到了自己发送的 `MEET` 消息，接着节点 A 向节点 B 返回一条 `PING` 消息
 6. 节点 B 接收到节点 A 的 `PING` 消息，握手完成
 7. 节点 A 将节点 B 的信息通过 Gossip 协议传播给集群中的其他节点，让其他节点与 B 握手

#### 2.2 槽分片

Redis 通过分片的形式存储键值对：集群分为 16384 个槽，集群中的每一个键都属于这些槽中的一个。当 13684 个槽都有节点处理时，集群才处于 OK 状态，如果有一个槽没有被份额皮，那么集群就处于下线状态。

槽分配使用 `CLUSTER ADDSLOTS <slot> [slot ...]` 命令实现。集群中的每个节点除了会记录槽信息外还会将这些信息通过消息发送给集群中的其他节点，这样一来集群中的每个节点都会知道 13684 个槽都给分配给了哪个节点。


#### 2.3 MOVED 错误







### 参考

《Redis 设计与实现》 <br>
[深入学习 Redis（5）：集群 ](https://www.cnblogs.com/kismetv/p/9853040.html) <br>